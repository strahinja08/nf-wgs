// --params.path 
// nextflow 1st priority 
// 
// --bwapath prosledi. 
//

params {
    cpus   = { check_max( 1    * task.attempt, 'cpus'   ) }
    memory = { check_max( 6.GB * task.attempt, 'memory' ) }
    time   = { check_max( 4.h  * task.attempt, 'time'   ) }

    errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
    maxRetries    = 1
    maxErrors     = '-1'

    // Max resource options
    // Defaults only, expecting to be overwritten
    max_memory                 = '128.GB'
    max_cpus                   = 16
    max_time                   = '240.h'
}

profile {
    'standard' {
         params {
            config_profile_description = 'Production workflow'
            config_profile_name = 'Standard profile'

            // Resources
            max_cpus = 8
            max_memory = 12.GB
            max_time = 72.h

            // TODO: independent input data
            input = "$baseDir/data/reads/*_ercc_{1,2}.fq.gz"

            // Reference genome
            genome = 'ref_genome'
            genomes_base = "$baseDir/data/reference_genome/test.ref.ercc.fa"

            outdir = "$baseDir/results/STANDARD" 
            }
    }

    'test' {
        params {
            config_profile_description = 'Minimal test dataset to check pipeline function'
            config_profile_name = 'Test profile'

            // Limit resources so that this can run on GitHub Actions
            max_cpus = 2
            max_memory = 6.GB
            max_time = 48.h

            // Input data
            input = "$baseDir/data/reads/*rna_{1,2}.fq.gz"

            // Small reference genome
            genome = 'ref_genome'
            genomes_base = "$baseDir/data/reference_genome/test.ref.fa"

            outdir = "$baseDir/results/TEST"
            }
    }
}

process {
    withName:FASTQC {
        container = 'fastqc'
        cpus = 2
        memory = 1.GB
        queue = 'default'
        publishDir = [
            path: { "${params.outdir}/FastQC" },
        ]
    }
    
    // ASK: case: two paths needed ?
    withName:BWAINDEX {
        container = 'bwa:latest'
        publishDir = [
            path: { "${params.bwasam}" },
        ]
    }
    
    withName:BWAMEM {
        container = 'bwa:latest'
        publishDir = [
            path: { "${params.bwa}}" },
        ]
    }

    withName:BWAMEM_SAMTOOLS_SORT {
        // ISSUE: base image to wgs maybe
        container = 'bwa-sam:latest'
        publishDir = [
            path: {"${params.bwasam}"},
            mode: "copy"
        ]
    }
    
    withName:"^SAMTOOLS.*" {
        container = 'samtools'
        cpus = 2
        memory = 1.GB
        publishDir = [
            path: { "${params.outdir}/Samtools" },
        ]
    }

    withName:MARKDUPLICATES {
        container = 'gatk:latest'
        publishDir = [
            path: { "${params.outdir}/MarkDuplicates" },
        ]
    }
    withName:BASERECALIBRATOR {
        container = 'gatk:latest'
        publishDir = [
            path: { "${params.outdir}/BaseRecalibrator" },
        ]
    }
      withName:APPLYBQSR {
        container = 'gatk:latest'
        publishDir = [
            path: { "${params.outdir}/BaseRecalibrator" },
        ]
    }

    withName:QUALIMAP {
            cpus = 1
            memory = 40
            
            // TODO: ok ?
            help          = null
            output_format = "html"
            publishDir = [
                path: { "${params.outdir}/Qualimap" },
            ]
    }

    withName:"MULTIQC*." {
        container = 'multiqc:latest'
        cpus = params.max_cpus
        memory = params.max_memory
        
        publishDir = [
            path: { "${params.outdir}/Reports/MultiQC" },
            mode: params.publish_dir_mode,
        ]
    }
}

process {
    withLabel: big_mem {
        cpus = 16
        memory = 64.GB
        queue = 'long'
    }
}
   

     